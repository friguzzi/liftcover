%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{LIFTCOVER Documentation}
\date{Feb 15, 2024}
\release{1.0.0}
\author{Fabrizio Riguzzi}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introduction}
\label{\detokenize{index:introduction}}\begin{description}
\sphinxlineitem{LIFTCOVER is a system for learning simple probabilistic logic programs with scalability in mind}
\sphinxAtStartPar
{[}\hyperlink{cite.index:id7}{GBA+23}, \hyperlink{cite.index:id34}{NFR19}{]}.

\end{description}


\chapter{Predicate Reference}
\label{\detokenize{index:predicate-reference}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://friguzzi.github.io/liftcover/pldoc/liftcover.html}{liftcover}

\end{itemize}


\chapter{Installation}
\label{\detokenize{index:installation}}
\sphinxAtStartPar
LIFTCOVER is distributed as a \sphinxhref{http://www.swi-prolog.org/pack/list?p=liftcover}{pack} of \sphinxhref{http://www.swi-prolog.org/}{SWI\sphinxhyphen{}Prolog}.
To install it, use

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} swipl
?\PYGZhy{} pack\PYGZus{}install(liftcover).
\end{sphinxVerbatim}


\section{Requirements}
\label{\detokenize{index:requirements}}
\sphinxAtStartPar
It uses the packs
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/friguzzi/lbfgs}{lbfgs}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/friguzzi/auc}{auc}

\end{itemize}

\sphinxAtStartPar
They are installed automatically when installing pack \sphinxtitleref{liftcover} or can be installed manually as follows

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} swipl
?\PYGZhy{} pack\PYGZus{}install(lbfgs).
?\PYGZhy{} pack\PYGZus{}install(auc).
\end{sphinxVerbatim}

\sphinxAtStartPar
Pack \sphinxtitleref{lbfgs} is optional, if absent the versions of the algorithms that use  \sphinxtitleref{lbfgs} do not work but the other versions work.

\sphinxAtStartPar
Parameter learning can be performed using Python and the Python packages \sphinxhref{https://www.numpy.org/}{numpy}, \sphinxhref{https://pytorch.org/}{torch} and \sphinxhref{https://cupy.dev/}{cupy}, either on CPU or GPU.
If they are not installed, the algorithms that use them do not work, but you can still run the Prolog version of parameter learning.

\sphinxAtStartPar
You can upgrade the pack with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} swipl
?\PYGZhy{} pack\PYGZus{}upgrade(liftcover).
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the packs on which \sphinxtitleref{liftcover} depends are not upgraded automatically.
In this case, they need to be upgraded manually.


\section{Example of use}
\label{\detokenize{index:example-of-use}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd \PYGZlt{}pack\PYGZgt{}/liftcover/prolog/examples
\PYGZdl{} swipl
?\PYGZhy{} [muta].
?\PYGZhy{} induce\PYGZus{}par\PYGZus{}lift([1,2,3,4,5,6,7,8,9],P).
\end{sphinxVerbatim}


\section{Testing the installation}
\label{\detokenize{index:testing-the-installation}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} swipl
?\PYGZhy{} [library(test\PYGZus{}liftcover)].
?\PYGZhy{} test.
\end{sphinxVerbatim}


\chapter{Syntax}
\label{\detokenize{index:syntax}}
\sphinxAtStartPar
LIFTCOVER learns \sphinxstyleemphasis{liftable probabilistic logic programs} a restricted version of Logic programs with annotated disjunctions LPADs ({[}\hyperlink{cite.index:id24}{VV03}, \hyperlink{cite.index:id8}{VVB04}{]}). A HPLP is a set of annotated clauses whose head contain a single atom annotated with a probability. For the rest, the usual syntax of Prolog is used.

\sphinxAtStartPar
A clause in such a program has a single head with the \sphinxstyleemphasis{target predicate} (the predicate you want to learn)
and a body composed of \sphinxstyleemphasis{input predicates} or predicates defined by deterministic clauses (typically facts).

\sphinxAtStartPar
A general HPLP clause has the following form:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{h}\PYG{p}{:}\PYG{n}{p}\PYG{p}{:}\PYG{o}{\PYGZhy{}} \PYG{n}{b1}\PYG{p}{,}\PYG{n}{b2}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}\PYG{n}{bn}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
The following example inspired from the UWCSE dataset used in {[}\hyperlink{cite.index:id29}{KD05}{]} is represented as (file \sphinxhref{http://cplint.eu/e/phil/uwcse.pl}{uwcse.pl})

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{advisedby}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}\PYG{p}{:}\PYG{l+m+mf}{0.3} \PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{n}{student}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{,}\PYG{n}{professor}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{p}{,}\PYG{n}{project}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{C}\PYG{p}{)}\PYG{p}{,}\PYG{n}{project}\PYG{p}{(}\PYG{n}{B}\PYG{p}{,}\PYG{n}{C}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{advisedby}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}\PYG{p}{:}\PYG{l+m+mf}{0.6} \PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{n}{student}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{,}\PYG{n}{professor}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{p}{,}\PYG{n}{ta}\PYG{p}{(}\PYG{n}{C}\PYG{p}{,}\PYG{n}{A}\PYG{p}{)}\PYG{p}{,}\PYG{n}{taughtby}\PYG{p}{(}\PYG{n}{C}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}\PYG{o}{.}

\PYG{n}{student}\PYG{p}{(}\PYG{n}{harry}\PYG{p}{)}\PYG{o}{.} \PYG{n}{professor}\PYG{p}{(}\PYG{n}{ben}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{project}\PYG{p}{(}\PYG{n}{harry}\PYG{p}{,}\PYG{n}{pr1}\PYG{p}{)}\PYG{o}{.} \PYG{n}{project}\PYG{p}{(}\PYG{n}{harry}\PYG{p}{,}\PYG{n}{pr2}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{project}\PYG{p}{(}\PYG{n}{ben}\PYG{p}{,}\PYG{n}{pr1}\PYG{p}{)}\PYG{o}{.} \PYG{n}{project}\PYG{p}{(}\PYG{n}{ben}\PYG{p}{,}\PYG{n}{pr2}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{taughtby}\PYG{p}{(}\PYG{n}{c1}\PYG{p}{,}\PYG{n}{ben}\PYG{p}{)}\PYG{o}{.} \PYG{n}{taughtby}\PYG{p}{(}\PYG{n}{c2}\PYG{p}{,}\PYG{n}{ben}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{ta}\PYG{p}{(}\PYG{n}{c\PYGZus{}1}\PYG{p}{,}\PYG{n}{harry}\PYG{p}{)}\PYG{o}{.} \PYG{n}{ta}\PYG{p}{(}\PYG{n}{c\PYGZus{}2}\PYG{p}{,}\PYG{n}{harry}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{publication(A,B,C)}} means that A is a publication with author B produced in project C.
\sphinxcode{\sphinxupquote{advisedby/2}} is the target predicate and \sphinxcode{\sphinxupquote{student/1, professor/1, project/2, ta/2, taughtby/2}}
are input predicates.
\begin{description}
\sphinxlineitem{The first clause states that a student A is advised by a professor B with probability 0.3 if they both}
\sphinxAtStartPar
work on the same project C.

\sphinxlineitem{The second states that a student A is advised by a professor B with probability 0.6 if the student}
\sphinxAtStartPar
is a teacher assistant in a course taught by the professor.

\sphinxlineitem{The facts in the program state that harry is a student and ben a professor.}
\sphinxAtStartPar
They have two joint courses c1 and c2, two joint projects pr1 and pr2.

\end{description}


\chapter{Semantics}
\label{\detokenize{index:semantics}}
\sphinxAtStartPar
The semantics of liftable PLP directly inherits the semantics of LPADs.


\chapter{Learning}
\label{\detokenize{index:learning}}

\section{Input}
\label{\detokenize{index:input}}
\sphinxAtStartPar
To execute the learning algorithms, prepare a Prolog file divided in five parts
\begin{itemize}
\item {} 
\sphinxAtStartPar
preamble

\item {} 
\sphinxAtStartPar
background knowledge, i.e., knowledge valid for all interpretations

\item {} 
\sphinxAtStartPar
liftable PLP for which you want to learn the parameters (optional)

\item {} 
\sphinxAtStartPar
language bias information

\item {} 
\sphinxAtStartPar
example interpretations

\end{itemize}

\sphinxAtStartPar
The preamble must come first, the order of the other parts can be changed.

\sphinxAtStartPar
For example, consider the Bongard problems of {[}\hyperlink{cite.index:id22}{DRVL95}{]}. \sphinxhref{http://cplint.eu/e/lift/bongard.pl}{bongard.pl} and \sphinxhref{http://cplint.eu/e/lift/bongardkeys.pl}{bongardkeys.pl} represent a Bongard problem for LIFTCOVER.


\subsection{Preamble}
\label{\detokenize{index:preamble}}
\sphinxAtStartPar
In the preamble, the LIFTCOVER library is loaded with (\sphinxhref{http://cplint.eu/e/lift/bongard.pl}{bongard.pl}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{:}\PYG{o}{\PYGZhy{}} \PYG{n}{use\PYGZus{}module}\PYG{p}{(}\PYG{n}{library}\PYG{p}{(}\PYG{n}{liftcover}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now you can initialize  with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{:}\PYG{o}{\PYGZhy{}} \PYG{n}{lift}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
At this point you can start setting parameters for SLEAHP such as for example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{:}\PYG{o}{\PYGZhy{}} \PYG{n}{set\PYGZus{}lift}\PYG{p}{(}\PYG{n}{megaex\PYGZus{}bottom}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{o}{.}
\PYG{p}{:}\PYG{o}{\PYGZhy{}} \PYG{n}{set\PYGZus{}lift}\PYG{p}{(}\PYG{n}{min\PYGZus{}probability}\PYG{p}{,}\PYG{l+m+mf}{0.00001}\PYG{p}{)}\PYG{o}{.}
\PYG{p}{:}\PYG{o}{\PYGZhy{}} \PYG{n}{set\PYGZus{}lift}\PYG{p}{(}\PYG{n}{verbosity}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
We will later see the list of available parameters.


\subsection{Background and Initial hierarchical program}
\label{\detokenize{index:background-and-initial-hierarchical-program}}
\sphinxAtStartPar
Now you can specify the background knowledge with a fact of the form

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{bg}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{list} \PYG{n}{of} \PYG{n}{terms} \PYG{n}{representing} \PYG{n}{clauses}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
where the clauses must be deterministic.
Alternatively, you can specify a set of clauses by including them in a section between \sphinxcode{\sphinxupquote{:\sphinxhyphen{} begin\_bg.}} and \sphinxcode{\sphinxupquote{:\sphinxhyphen{} end\_bg.}}
Moreover, you can specify an initial program with a fact of the form

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o+ow}{in}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{list} \PYG{n}{of} \PYG{n}{terms} \PYG{n}{representing} \PYG{n}{clauses}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
The initial program is used in parameter learning for providing the structure.
Remember to enclose each clause in parentheses because \sphinxcode{\sphinxupquote{:\sphinxhyphen{}}} has the highest precedence.

\sphinxAtStartPar
For example, \sphinxhref{http://cplint.eu/e/lift/bongard.pl}{bongard.pl} has the initial program

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o+ow}{in}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{n}{pos}\PYG{p}{:}\PYG{l+m+mf}{0.197575} \PYG{p}{:}\PYG{o}{\PYGZhy{}}
   \PYG{n}{circle}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{,}
   \PYG{o+ow}{in}\PYG{p}{(}\PYG{n}{B}\PYG{p}{,}\PYG{n}{A}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{(}\PYG{n}{pos}\PYG{p}{:}\PYG{l+m+mf}{0.000303421} \PYG{p}{:}\PYG{o}{\PYGZhy{}}
   \PYG{n}{circle}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{,}
   \PYG{n}{triangle}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{(}\PYG{n}{pos}\PYG{p}{:}\PYG{l+m+mf}{0.000448807} \PYG{p}{:}\PYG{o}{\PYGZhy{}}
   \PYG{n}{triangle}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{,}
   \PYG{n}{circle}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Alternatively, you can specify an input program in a section between \sphinxcode{\sphinxupquote{:\sphinxhyphen{} begin\_in.}} and \sphinxcode{\sphinxupquote{:\sphinxhyphen{} end\_in.}} as for example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{:}\PYG{o}{\PYGZhy{}} \PYG{n}{begin\PYGZus{}in}\PYG{o}{.}

\PYG{n}{pos}\PYG{p}{:}\PYG{l+m+mf}{0.197575} \PYG{p}{:}\PYG{o}{\PYGZhy{}}
        \PYG{n}{circle}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{,}
        \PYG{o+ow}{in}\PYG{p}{(}\PYG{n}{B}\PYG{p}{,}\PYG{n}{A}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{pos}\PYG{p}{:}\PYG{l+m+mf}{0.000303421} \PYG{p}{:}\PYG{o}{\PYGZhy{}}
        \PYG{n}{circle}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{,}
        \PYG{n}{triangle}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{pos}\PYG{p}{:}\PYG{l+m+mf}{0.000448807} \PYG{p}{:}\PYG{o}{\PYGZhy{}}
        \PYG{n}{triangle}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{,}
        \PYG{n}{circle}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{o}{.}

\PYG{p}{:}\PYG{o}{\PYGZhy{}} \PYG{n}{end\PYGZus{}in}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you specify both a \sphinxcode{\sphinxupquote{in/1}} fact and a section, the clauses of the two will be combined.

\sphinxAtStartPar
The annotations of the head atoms of the initial program can be probabilities, as in the example above. In parameter learning, the learning procedure can start with the initial parameters in the program. In this case, it is up to the user to ensure that there are values between 0 and 1. In the case of structure learning, the initial program is not necessary.


\subsection{Language Bias}
\label{\detokenize{index:language-bias}}
\sphinxAtStartPar
The language bias part contains the declarations of the input and output predicates.
The output predicate is declared as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{output}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{predicate}\PYG{o}{\PYGZgt{}}\PYG{o}{/}\PYG{o}{\PYGZlt{}}\PYG{n}{arity}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
and indicates the predicate whose atom you want to predict (target predicate).
Derivations for the atoms for this predicate in the input data is built by the system.
Input predicates are those whose atoms you are not interested in predicting.
You can declare input predicates with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{input}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{predicate}\PYG{o}{\PYGZgt{}}\PYG{o}{/}\PYG{o}{\PYGZlt{}}\PYG{n}{arity}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
For these predicates, the only true atoms are those in the interpretations and those derivable from them using the background knowledge.

\sphinxAtStartPar
Then, for structure learning you have to specify the language bias by means of mode declarations in the style of \sphinxhref{https://www.doc.ic.ac.uk/~shm/progol.html}{Progol}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{modeh}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{recall}\PYG{o}{\PYGZgt{}}\PYG{p}{,}\PYG{o}{\PYGZlt{}}\PYG{n}{predicate}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{arg1}\PYG{o}{\PYGZgt{}}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
specifies the atoms that can appear in the head of clauses.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{modeb}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{recall}\PYG{o}{\PYGZgt{}}\PYG{p}{,}\PYG{o}{\PYGZlt{}}\PYG{n}{predicate}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{arg1}\PYG{o}{\PYGZgt{}}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
specifies the atoms that can appear in the body of clauses. \sphinxcode{\sphinxupquote{\textless{}recall\textgreater{}}} can be an integer or \sphinxcode{\sphinxupquote{*}}. \sphinxcode{\sphinxupquote{\textless{}recall\textgreater{}}} indicates how many atoms for the predicate specification are retained in the bottom clause during a saturation step. \sphinxcode{\sphinxupquote{*}} stands for all those that are found.
Otherwise the indicated number of atoms are randomly chosen.

\sphinxAtStartPar
Arguments of the form

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{+}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{type}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
specifies that the argument should be an input variable of type \sphinxcode{\sphinxupquote{\textless{}type\textgreater{}}}, i.e., a variable replacing a \sphinxcode{\sphinxupquote{+\textless{}type\textgreater{}}} argument in the head or a \sphinxcode{\sphinxupquote{\sphinxhyphen{}\textless{}type\textgreater{}}} argument in a preceding literal in the current hypothesized clause.

\sphinxAtStartPar
Another argument form is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{type}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
for specifying that the argument should be a output variable of type \sphinxcode{\sphinxupquote{\textless{}type\textgreater{}}}.
Any variable can replace this argument, either input or output.
The only constraint on output variables is that those in the head of a clause must appear as output variables in an atom in the body.

\sphinxAtStartPar
Other forms are

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZlt{}type\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
for specifying an argument which should be replaced by a constant of type \sphinxcode{\sphinxupquote{\textless{}type\textgreater{}}} in the bottom clause but should not be used for replacing input variables of the following literals when building the bottom clause or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{c+c1}{\PYGZsh{}\PYGZlt{}type\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
for specifying an argument which should be replaced by a constant of type \sphinxcode{\sphinxupquote{\textless{}type\textgreater{}}} in the bottom clause and that should be used for replacing input variables of the following literals when building the bottom clause.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{constant}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
for specifying a constant.

\sphinxAtStartPar
An example of language bias for the Bongard domain is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{output}\PYG{p}{(}\PYG{n}{pos}\PYG{o}{/}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}

\PYG{n+nb}{input}\PYG{p}{(}\PYG{n}{triangle}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}
\PYG{n+nb}{input}\PYG{p}{(}\PYG{n}{square}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}
\PYG{n+nb}{input}\PYG{p}{(}\PYG{n}{circle}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}
\PYG{n+nb}{input}\PYG{p}{(}\PYG{o+ow}{in}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}
\PYG{n+nb}{input}\PYG{p}{(}\PYG{n}{config}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}

\PYG{n}{modeh}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{n}{pos}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{modeb}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{n}{triangle}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{obj}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{modeb}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{n}{square}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{obj}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{modeb}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{n}{circle}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{obj}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{modeb}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o+ow}{in}\PYG{p}{(}\PYG{o}{+}\PYG{n}{obj}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{obj}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{modeb}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{o+ow}{in}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{obj}\PYG{p}{,}\PYG{o}{+}\PYG{n}{obj}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{modeb}\PYG{p}{(}\PYG{o}{*}\PYG{p}{,}\PYG{n}{config}\PYG{p}{(}\PYG{o}{+}\PYG{n}{obj}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{c+c1}{\PYGZsh{}dir)).}
\end{sphinxVerbatim}

\sphinxAtStartPar
LIFTCOVER also requires facts for the \sphinxcode{\sphinxupquote{determination/2}} Aleph\sphinxhyphen{}style predicate that indicate which predicates can appear in the body of clauses.
For example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{determination}\PYG{p}{(}\PYG{n}{pos}\PYG{o}{/}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{triangle}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{determination}\PYG{p}{(}\PYG{n}{pos}\PYG{o}{/}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{square}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{determination}\PYG{p}{(}\PYG{n}{pos}\PYG{o}{/}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{circle}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{determination}\PYG{p}{(}\PYG{n}{pos}\PYG{o}{/}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o+ow}{in}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{determination}\PYG{p}{(}\PYG{n}{pos}\PYG{o}{/}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{config}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
state that \sphinxcode{\sphinxupquote{triangle/1}} can appear in the body of clauses for \sphinxcode{\sphinxupquote{pos/0}}.


\subsection{Example Interpretations}
\label{\detokenize{index:example-interpretations}}
\sphinxAtStartPar
The last part of the file contains the data.
You can specify data with two modalities: models and keys.
In the models case, you specify an example model (or interpretation or mega\sphinxhyphen{}example) as a list of Prolog facts initiated by \sphinxcode{\sphinxupquote{begin(model(\textless{}name\textgreater{})).}} and terminated by \sphinxcode{\sphinxupquote{end(model(\textless{}name\textgreater{})).}} as in

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{begin}\PYG{p}{(}\PYG{n}{model}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{pos}\PYG{o}{.}
\PYG{n}{triangle}\PYG{p}{(}\PYG{n}{o5}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{config}\PYG{p}{(}\PYG{n}{o5}\PYG{p}{,}\PYG{n}{up}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{square}\PYG{p}{(}\PYG{n}{o4}\PYG{p}{)}\PYG{o}{.}
\PYG{o+ow}{in}\PYG{p}{(}\PYG{n}{o4}\PYG{p}{,}\PYG{n}{o5}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{circle}\PYG{p}{(}\PYG{n}{o3}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{triangle}\PYG{p}{(}\PYG{n}{o2}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{config}\PYG{p}{(}\PYG{n}{o2}\PYG{p}{,}\PYG{n}{up}\PYG{p}{)}\PYG{o}{.}
\PYG{o+ow}{in}\PYG{p}{(}\PYG{n}{o2}\PYG{p}{,}\PYG{n}{o3}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{triangle}\PYG{p}{(}\PYG{n}{o1}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{config}\PYG{p}{(}\PYG{n}{o1}\PYG{p}{,}\PYG{n}{up}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{end}\PYG{p}{(}\PYG{n}{model}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
The facts in the interpretation are loaded in SWI\sphinxhyphen{}Prolog database by adding an extra initial argument equal to the name of the model.
After each interpretation is loaded, a fact of the form \sphinxcode{\sphinxupquote{int(\textless{}id\textgreater{})}} is asserted, where \sphinxcode{\sphinxupquote{id}} is the name of the interpretation.
This can be used in order to retrieve the list of interpretations.

\sphinxAtStartPar
Alternatively, with the keys modality, you can directly write the facts and the first argument will be interpreted as a model identifier.
The above interpretation in the keys modality is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{triangle}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{o5}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{config}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{o5}\PYG{p}{,}\PYG{n}{up}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{o4}\PYG{p}{)}\PYG{o}{.}
\PYG{o+ow}{in}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{o4}\PYG{p}{,}\PYG{n}{o5}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{circle}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{o3}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{triangle}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{o2}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{config}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{o2}\PYG{p}{,}\PYG{n}{up}\PYG{p}{)}\PYG{o}{.}
\PYG{o+ow}{in}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{o2}\PYG{p}{,}\PYG{n}{o3}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{triangle}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{o1}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{config}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{o1}\PYG{p}{,}\PYG{n}{up}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
which is contained in the \sphinxhref{http://cplint.eu/e/lift/bongardkeys.pl}{bongardkeys.pl}.
This is also how model \sphinxcode{\sphinxupquote{2}} above is stored in SWI\sphinxhyphen{}Prolog database.
The two modalities, models and keys, can be mixed in the same file.
Facts for \sphinxcode{\sphinxupquote{int/1}} are not asserted for interpretations in the key modality but can be added by the user explicitly.

\sphinxAtStartPar
Note that you can add background knowledge that is not probabilistic directly to the file writing clauses taking into account the model argument.
For example (\sphinxcode{\sphinxupquote{carc.pl}}), contains

\begin{sphinxVerbatim}[commandchars=\\\{\}]
connected(\PYGZus{}M,Ring1,Ring2):\PYGZhy{}
        Ring1 \PYGZbs{}= Ring2,
        member(A,Ring1),
        member(A,Ring2), !.

symbond(Mod,A,B,T):\PYGZhy{} bond(Mod,A,B,T).
symbond(Mod,A,B,T):\PYGZhy{} bond(Mod,B,A,T).
\end{sphinxVerbatim}

\sphinxAtStartPar
where the first argument of all atoms is the model.

\sphinxAtStartPar
Then you must indicate how examples are divided in folds with facts of the form: \sphinxcode{\sphinxupquote{fold(\textless{}fold\_name\textgreater{},\textless{}list of model identifiers\textgreater{})}}, as for example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fold}\PYG{p}{(}\PYG{n}{train}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}
\PYG{n}{fold}\PYG{p}{(}\PYG{n}{test}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{490}\PYG{p}{,}\PYG{l+m+mi}{491}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
As the input file is a Prolog program, you can define intentionally the folds as in

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fold}\PYG{p}{(}\PYG{n+nb}{all}\PYG{p}{,}\PYG{n}{F}\PYG{p}{)}\PYG{p}{:}\PYG{o}{\PYGZhy{}}
\PYG{n}{findall}\PYG{p}{(}\PYG{n}{I}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{I}\PYG{p}{)}\PYG{p}{,}\PYG{n}{F}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fold/2}} is dynamic so you can also write

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{:}\PYG{o}{\PYGZhy{}} \PYG{n}{fold}\PYG{p}{(}\PYG{n+nb}{all}\PYG{p}{,}\PYG{n}{F}\PYG{p}{)}\PYG{p}{,}
\PYG{n}{sample\PYGZus{}lift}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{F}\PYG{p}{,}\PYG{n}{FTr}\PYG{p}{,}\PYG{n}{FTe}\PYG{p}{)}\PYG{p}{,}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{fold}\PYG{p}{(}\PYG{n}{rand\PYGZus{}train}\PYG{p}{,}\PYG{n}{FTr}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{k}{assert}\PYG{p}{(}\PYG{n}{fold}\PYG{p}{(}\PYG{n}{rand\PYGZus{}test}\PYG{p}{,}\PYG{n}{FTe}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
which however must be inserted after the input interpretations otherwise the facts for \sphinxcode{\sphinxupquote{int/1}} will not be available and the fold \sphinxcode{\sphinxupquote{all}} would be empty.
This command uses \sphinxcode{\sphinxupquote{sample\_lift(N,List,Sampled,Rest)}} exported from \sphinxcode{\sphinxupquote{liftcover}}
that samples \sphinxcode{\sphinxupquote{N}} elements from \sphinxcode{\sphinxupquote{List}} and returns the sampled elements in \sphinxcode{\sphinxupquote{Sampled}} and the rest in \sphinxcode{\sphinxupquote{Rest}}.
If \sphinxcode{\sphinxupquote{List}} has \sphinxcode{\sphinxupquote{N}} elements or less, \sphinxcode{\sphinxupquote{Sampled}} is equal to \sphinxcode{\sphinxupquote{List}} and \sphinxcode{\sphinxupquote{Rest}} is empty.


\section{Commands}
\label{\detokenize{index:commands}}

\subsection{Parameter Learning}
\label{\detokenize{index:parameter-learning}}
\sphinxAtStartPar
To execute LIFTCOVER, prepare an input file as indicated above and call

\begin{sphinxVerbatim}[commandchars=\\\{\}]
?\PYGZhy{} induce\PYGZus{}lift\PYGZus{}par(+List\PYGZus{}of\PYGZus{}folds:list,\PYGZhy{}P:list).
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{\textless{}list of folds\textgreater{}}} is a list of the folds for training and \sphinxcode{\sphinxupquote{P}} will contain
the input program with updated parameters.

\sphinxAtStartPar
For example \sphinxhref{http://cplint.eu/e/lift/bongard.pl}{bongard.pl}, you can perform parameter learning on the \sphinxcode{\sphinxupquote{train}} fold with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
?\PYGZhy{} induce\PYGZus{}lift\PYGZus{}par([train],P).
\end{sphinxVerbatim}

\sphinxAtStartPar
The algorithm that is used for parameter learning is specified by
the parameter \sphinxcode{\sphinxupquote{parameter\_learning}} that can be set to
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{em}}, for Expectation Maximization, in Prolog

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{em\_python}}, for Expectation Maximization, in Python, using either \sphinxcode{\sphinxupquote{cpu}} or \sphinxcode{\sphinxupquote{gpu}}, depending on the value of the \sphinxcode{\sphinxupquote{processor}} parameter. In the first case, \sphinxtitleref{numpy} is used, in the latter case \sphinxtitleref{cupy} is used.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gd}}, for Gradient Descent, in Prolog

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gd\_python}}, for Gradient Descent, in Python, using Pytorch, using either \sphinxcode{\sphinxupquote{cpu}} or \sphinxcode{\sphinxupquote{gpu}}, depending on the value of the \sphinxcode{\sphinxupquote{processor}} parameter. In both cases, \sphinxtitleref{torch} is used.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lbfgs}} for Limited\sphinxhyphen{}memory Broyden\sphinxhyphen{}Fletcher\sphinxhyphen{}Goldfarb\sphinxhyphen{}Shanno, in Prolog and C

\end{itemize}


\subsection{Structure Learning}
\label{\detokenize{index:structure-learning}}
\sphinxAtStartPar
To execute LIFTCOVER, prepare an input file in the editor panel as indicated above and call

\begin{sphinxVerbatim}[commandchars=\\\{\}]
?\PYGZhy{} induce\PYGZus{}lift(+List\PYGZus{}of\PYGZus{}folds:list,\PYGZhy{}P:list).
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{List\_of\_folds}} is a list of the folds for training and \sphinxcode{\sphinxupquote{P}} will contain the learned program.

\sphinxAtStartPar
For example \sphinxhref{http://cplint.eu/e/lift/bongard.pl}{bongard.pl}, you can perform structure learning on the \sphinxcode{\sphinxupquote{train}} fold with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
?\PYGZhy{} induce\PYGZus{}lift([train],P).
\end{sphinxVerbatim}

\sphinxAtStartPar
A program can also be tested on a test set with \sphinxcode{\sphinxupquote{test\_lift/7}}  as described below.


\subsection{Helper Predicates}
\label{\detokenize{index:helper-predicates}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sort\PYGZus{}rules}\PYG{p}{(}\PYG{o}{+}\PYG{n}{RulesIn}\PYG{p}{:}\PYG{n}{list\PYGZus{}of\PYGZus{}rules}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{RulesOut}\PYG{p}{:}\PYG{n}{list\PYGZus{}of\PYGZus{}rules}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{det}
\end{sphinxVerbatim}

\sphinxAtStartPar
The predicate sorts \sphinxcode{\sphinxupquote{RulesIn}} according to the probability of the rules.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{filter\PYGZus{}rules}\PYG{p}{(}\PYG{o}{+}\PYG{n}{RulesIn}\PYG{p}{:}\PYG{n}{list\PYGZus{}of\PYGZus{}rules}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{RulesOut}\PYG{p}{:}\PYG{n}{list\PYGZus{}of\PYGZus{}rules}\PYG{p}{,}\PYG{o}{+}\PYG{n}{Min\PYGZus{}prob}\PYG{p}{:}\PYG{n+nb}{float}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{det}
\end{sphinxVerbatim}

\sphinxAtStartPar
The predicate removes the rules with a probability below or equal to \sphinxcode{\sphinxupquote{Min\_prob}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{filter\PYGZus{}rules}\PYG{p}{(}\PYG{p}{:}\PYG{n}{RulesIn}\PYG{p}{:}\PYG{n}{list\PYGZus{}of\PYGZus{}rules}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{RulesOut}\PYG{p}{:}\PYG{n}{list\PYGZus{}of\PYGZus{}rules}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{det}
\end{sphinxVerbatim}

\sphinxAtStartPar
The predicate removes the rules with a probability below or equal to the \sphinxcode{\sphinxupquote{min\_prob}} parmeter.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{remove\PYGZus{}zero}\PYG{p}{(}\PYG{o}{+}\PYG{n}{RulesIn}\PYG{p}{:}\PYG{n}{list\PYGZus{}of\PYGZus{}rules}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{RulesOut}\PYG{p}{:}\PYG{n}{list\PYGZus{}of\PYGZus{}rules}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{det}
\end{sphinxVerbatim}

\sphinxAtStartPar
The predicate removes the rules with a probability of 0.0.


\subsection{Testing}
\label{\detokenize{index:testing}}
\sphinxAtStartPar
A program can also be tested on a test set in LIFTCOVER with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{test\PYGZus{}lift}\PYG{p}{(}\PYG{o}{+}\PYG{n}{Program}\PYG{p}{:}\PYG{n+nb}{list}\PYG{p}{,}\PYG{o}{+}\PYG{n}{List\PYGZus{}of\PYGZus{}folds}\PYG{p}{:}\PYG{n+nb}{list}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{LL}\PYG{p}{:}\PYG{n+nb}{float}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{AUCROC}\PYG{p}{:}\PYG{n+nb}{float}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{ROC}\PYG{p}{:}\PYG{n+nb}{list}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{AUCPR}\PYG{p}{:}\PYG{n+nb}{float}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{PR}\PYG{p}{:}\PYG{n+nb}{list}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{det}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{Program}} is a list of terms representing clauses and \sphinxcode{\sphinxupquote{List\_of\_folds}} is a list of folds.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{test\_lift/7}} returns the log likelihood of the test examples in \sphinxcode{\sphinxupquote{LL}}, the Area Under the ROC curve in \sphinxcode{\sphinxupquote{AUCROC}}, a dictionary containing the list of points (in the form of Prolog pairs \sphinxcode{\sphinxupquote{x\sphinxhyphen{}y}}) of the ROC curve in \sphinxcode{\sphinxupquote{ROC}}, the Area Under the PR curve in \sphinxcode{\sphinxupquote{AUCPR}}, a dictionary containing the list of points of the PR curve in \sphinxcode{\sphinxupquote{PR}}.

\sphinxAtStartPar
Then you can draw the curves using C3.js as follows

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{compute\PYGZus{}areas\PYGZus{}diagrams}\PYG{p}{(}\PYG{o}{+}\PYG{n}{ExampleList}\PYG{p}{:}\PYG{n+nb}{list}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{AUCROC}\PYG{p}{:}\PYG{n+nb}{float}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{ROC}\PYG{p}{:}\PYG{n+nb}{dict}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{AUCPR}\PYG{p}{:}\PYG{n+nb}{float}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{PR}\PYG{p}{:}\PYG{n+nb}{dict}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{det}
\end{sphinxVerbatim}

\sphinxAtStartPar
(from pack \sphinxhref{http://www.swi-prolog.org/pack/list?p=auc}{auc.pl}) that takes as input a list \sphinxcode{\sphinxupquote{ExampleList}} of pairs probability\sphinxhyphen{}literal.

\sphinxAtStartPar
For example, to test on fold \sphinxcode{\sphinxupquote{test}} the program learned on fold \sphinxcode{\sphinxupquote{train}} you can run the query

\begin{sphinxVerbatim}[commandchars=\\\{\}]
?\PYGZhy{} induce\PYGZus{}lift\PYGZus{}par([train],P),
test\PYGZus{}lift(P,[test],LL,AUCROC,ROC,AUCPR,PR).
\end{sphinxVerbatim}

\sphinxAtStartPar
Or you can test the input program on the fold \sphinxcode{\sphinxupquote{test}} with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
?\PYGZhy{} in(P),test\PYGZus{}lift(P,[test],LL,AUCROC,ROC,AUCPR,PR).
\end{sphinxVerbatim}

\sphinxAtStartPar
In SWISH, by including

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{:}\PYG{o}{\PYGZhy{}} \PYG{n}{use\PYGZus{}rendering}\PYG{p}{(}\PYG{n}{c3}\PYG{p}{)}\PYG{o}{.}
\PYG{p}{:}\PYG{o}{\PYGZhy{}} \PYG{n}{use\PYGZus{}rendering}\PYG{p}{(}\PYG{n}{lpad}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
in the code before \sphinxcode{\sphinxupquote{:\sphinxhyphen{} lift.}} the curves will be shown as graphs using C3.js and the output program will be pretty printed.

\sphinxAtStartPar
Predicates

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{prob\PYGZus{}lift}\PYG{p}{(}\PYG{p}{:}\PYG{n}{At}\PYG{p}{:}\PYG{n}{atom}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{P}\PYG{p}{:}\PYG{n+nb}{float}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{multi}
\PYG{n}{prob\PYGZus{}lift}\PYG{p}{(}\PYG{p}{:}\PYG{n}{At}\PYG{p}{:}\PYG{n}{atom}\PYG{p}{,}\PYG{o}{+}\PYG{n}{Program}\PYG{p}{:}\PYG{n}{probabilistic\PYGZus{}program}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{P}\PYG{p}{:}\PYG{n+nb}{float}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{multi}
\end{sphinxVerbatim}

\sphinxAtStartPar
compute the probability of atom \sphinxcode{\sphinxupquote{At}} given by the
input program the first and by \sphinxcode{\sphinxupquote{Program}} the latter.
The first argument of \sphinxcode{\sphinxupquote{At}} should be the model name.
If \sphinxcode{\sphinxupquote{At}} contains variables, the predicate returns
all the instantiaions of \sphinxcode{\sphinxupquote{At=}} with their probabilities in backtracking.

\sphinxAtStartPar
For example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
?\PYGZhy{} prob\PYGZus{}lift(pos(2),P).
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
?\PYGZhy{} prob\PYGZus{}lift(christian\PYGZus{}religion(f1,C),P).
C = \PYGZsq{}AMSA\PYGZsq{},
P = 0.409107 ;
C = \PYGZsq{}AUS\PYGZsq{},
P = 0.409107
...
\end{sphinxVerbatim}

\sphinxAtStartPar
Predicates

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ranked\PYGZus{}answers}\PYG{p}{(}\PYG{p}{:}\PYG{n}{At}\PYG{p}{:}\PYG{n}{atom}\PYG{p}{,}\PYG{o}{+}\PYG{n}{Var}\PYG{p}{:}\PYG{n}{var}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{RankedAnswers}\PYG{p}{:}\PYG{n+nb}{list}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{multi}
\PYG{n}{ranked\PYGZus{}answers}\PYG{p}{(}\PYG{p}{:}\PYG{n}{At}\PYG{p}{:}\PYG{n}{atom}\PYG{p}{,}\PYG{o}{+}\PYG{n}{Var}\PYG{p}{:}\PYG{n}{var}\PYG{p}{,}\PYG{o}{+}\PYG{n}{Program}\PYG{p}{:}\PYG{n}{probabilistic\PYGZus{}program}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{RankedAnswers}\PYG{p}{:}\PYG{n+nb}{list}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{multi}
\end{sphinxVerbatim}

\sphinxAtStartPar
return a list of answers for the query \sphinxcode{\sphinxupquote{At=.
:code:\textasciigrave{}Var}} should be a variable in \sphinxcode{\sphinxupquote{At}}. \sphinxcode{\sphinxupquote{RankedAnswers}} is a list of pairs
\sphinxcode{\sphinxupquote{(P\sphinxhyphen{}A)}} where \sphinxcode{\sphinxupquote{P}} is the probability of the answer \sphinxcode{\sphinxupquote{At\{Var/A\}}}.
The list is sorted in decreasing order of probability.
The first argument of \sphinxcode{\sphinxupquote{At \textasciigrave{}should be the model name.
The query is asked to the input program for :code:\textasciigrave{}ranked\_answers/3}} and to the
given progarm for \sphinxcode{\sphinxupquote{ranked\_answers/4}}.

\sphinxAtStartPar
Predicates

\begin{sphinxVerbatim}[commandchars=\\\{\}]
      \PYG{n}{explain\PYGZus{}lift}\PYG{p}{(}\PYG{p}{:}\PYG{n}{At}\PYG{p}{:}\PYG{n}{atom}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{Exp}\PYG{p}{:}\PYG{n+nb}{list}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{multi}
\PYG{n}{explain\PYGZus{}lift}\PYG{p}{(}\PYG{p}{:}\PYG{n}{At}\PYG{p}{:}\PYG{n}{atom}\PYG{p}{,}\PYG{o}{+}\PYG{n}{Program}\PYG{p}{:}\PYG{n}{probabilistic\PYGZus{}program}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{Exp}\PYG{p}{:}\PYG{n+nb}{list}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n}{multi1}
\end{sphinxVerbatim}

\sphinxAtStartPar
returns the explanation of atom \sphinxcode{\sphinxupquote{At}} given by the
input program. The first argument of \sphinxcode{\sphinxupquote{At}} should be the model name.
The explanation is a list of pairs \sphinxcode{\sphinxupquote{(P\sphinxhyphen{}Ex)}} where \sphinxcode{\sphinxupquote{P}} is the probability
in the head of a rule \sphinxcode{\sphinxupquote{H:P:\sphinxhyphen{}B}} and \sphinxcode{\sphinxupquote{Ex}} is a true grounding of \sphinxcode{\sphinxupquote{B}}.
The query is asked to the input program for \sphinxcode{\sphinxupquote{explain\_lift/2}} and to the
given progarm for \sphinxcode{\sphinxupquote{explain\_lift/3}}.


\section{Hyper\sphinxhyphen{}parameters for Learning}
\label{\detokenize{index:hyper-parameters-for-learning}}
\sphinxAtStartPar
Hyper\sphinxhyphen{}parameters are set with commands of the form

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{:}\PYG{o}{\PYGZhy{}} \PYG{n}{set\PYGZus{}lift}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}\PYG{p}{,}\PYG{o}{\PYGZlt{}}\PYG{n}{value}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
and read with commands of the form

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{:}\PYG{o}{\PYGZhy{}} \PYG{n}{setting\PYGZus{}lift}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{parameter}\PYG{o}{\PYGZgt{}}\PYG{p}{,}\PYG{o}{\PYGZlt{}}\PYG{n}{value}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{o}{.}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
hyper\sphinxhyphen{}parameters

\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{parameter\_learning}}: (values: \sphinxcode{\sphinxupquote{\{em,em\_python,gd,gd\_python,lbfgs\}}}, default value: \sphinxcode{\sphinxupquote{em}}) parameter learning algorithm

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{single\_var}} (values: \sphinxcode{\sphinxupquote{\{true,false\}}}, default value: \sphinxcode{\sphinxupquote{false}}): if set to \sphinxcode{\sphinxupquote{true}}, there is a random variable for each clause, instead of a different random variable for each grounding of each clause

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{processor}}: (values: \sphinxcode{\sphinxupquote{\{cpu,gpu\}}}, default value: \sphinxcode{\sphinxupquote{cpu}}) which processor Python will use for parameter learning

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{regularization}}: (values: \sphinxcode{\sphinxupquote{\{no,l1,l2,bayes\}}}, default value: \sphinxcode{\sphinxupquote{l1}}) type of regularization

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gamma}} (values: real number, default value: \sphinxcode{\sphinxupquote{10}}): regularization coefficient for L1 and L2

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ab}} (values: list of two real numbers, default value: \sphinxcode{\sphinxupquote{{[}0,10{]}}}): values of a and b for bayesian regularization

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{eta}} (values: real number, default value: \sphinxcode{\sphinxupquote{0.01}}): eta parameter in gradient descent (the parameters are updated as par=par+eta*gradient)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{max\_initial\_weight}} (values: real number , default value: 0.5): weights in lbfgs and gd are randomly initialized with values in the interval {[}\sphinxhyphen{}max\_initial\_weight, max\_initial\_weight{]}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{min\_probability}} (values: real number in \sphinxcode{\sphinxupquote{{[}0,1{]}}}, default value: \sphinxcode{\sphinxupquote{1e\sphinxhyphen{}5}}):  probability threshold under which a clause is dropped out.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{eps}} (values: real, default value: 0.0001): if the difference in the log likelihood in two successive parameter learning iterations is smaller than \sphinxcode{\sphinxupquote{eps}}, then parameter learning stops.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{eps\_f}} (values: real, default value: 0.00001): if the difference in the log likelihood in two successive parameter learning iterations is smaller than \sphinxcode{\sphinxupquote{eps\_f*(\sphinxhyphen{}current log likelihood)}}, then LIFTCOVER stops.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{random\_restarts\_number}} (values: integer, default value: 1): number of random restarts of parameter learning algorithms

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{random\_restarts\_number\_str\_learn}} (values: integer, default value: 1): number of random restarts during structure learning for learning the parameter of single clauses

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iter}} (values: integer, default value: \sphinxhyphen{}1): maximum number of parameter learning iterations (\sphinxhyphen{}1 means not limits)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{max\_iter}} (values: integer, default value: \sphinxcode{\sphinxupquote{10}}): iterations of clause search.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{beamsize}} (values: integer, default value: 100): size of the beam in the search for clauses

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{neg\_ex}} (values: \sphinxcode{\sphinxupquote{given}}, \sphinxcode{\sphinxupquote{cw}}, default value: \sphinxcode{\sphinxupquote{cw}}): if set to \sphinxcode{\sphinxupquote{given}}, the negative examples in training and testing are taken from the test folds interpretations, i.e., those examples \sphinxcode{\sphinxupquote{ex}} stored as \sphinxcode{\sphinxupquote{neg(ex)}}; if set to \sphinxcode{\sphinxupquote{cw}}, the negative examples in training and testing are generated according to the closed world assumption, i.e., all atoms for target predicates that are not positive examples. The set of all atoms is obtained by collecting the set of constants for each type of the arguments of the target predicate, so the target predicates must have at least one fact for \sphinxcode{\sphinxupquote{modeh/2}} or \sphinxcode{\sphinxupquote{modeb/2}} also for parameter learning.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{specialization}}: (values: \sphinxcode{\sphinxupquote{\{bottom,mode\}}}, default value: \sphinxcode{\sphinxupquote{bottom}}) specialization mode.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{megaex\_bottom}} (values: integer, default value: 1, valid for SLEAHP): number of mega\sphinxhyphen{}examples on which to build the bottom clauses.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{initial\_clauses\_per\_megaex}} (values: integer, default value: 1, valid for SLEAHP): number of bottom clauses to build for each mega\sphinxhyphen{}example (or model or interpretation).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{d}} (values: integer, default value: 1, valid for SLEAHP): number of saturation steps when building the bottom clause.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{max\_var}} (values: integer, default value: 4): maximum number of distinct variables in a clause

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{maxdepth\_var}} (values: integer, default value: 2): maximum depth of variables in clauses (as defined in {[}\hyperlink{cite.index:id23}{Coh95}{]}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{max\_body\_length}} (values: integer, default value: 100): maximum number of literals in the body of clauses

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{max\_clauses}} (values: integer, default value: 1000): maximum number of clauses in the theory

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{neg\_literals}} (values: \sphinxcode{\sphinxupquote{\{true,false\}}}, default value: \sphinxcode{\sphinxupquote{false}}): whether to consider negative literals when building the bottom clause

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{minus\_infinity}}: (values: real, default value: \sphinxhyphen{}1.0e20) minus infinity

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{logzero}} (values: negative real, default value \(\log(0.000001)\)): value assigned to \(\log(0)\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{zero}} (values: real, default value \(0.000001\)): value assigned to \(0\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{seed}} (values: seed(integer) or seed(random), default value \sphinxcode{\sphinxupquote{seed(3032)}}): seed for the Prolog random functions, see \sphinxhref{http://www.swi-prolog.org/pldoc/man?predicate=set\_random/1}{SWI\sphinxhyphen{}Prolog manual} .

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{verbosity}} (values: integer in \sphinxcode{\sphinxupquote{{[}1,4{]}}}, default value: \sphinxcode{\sphinxupquote{1}}): level of verbosity of the algorithms.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{threads}} (values: integer or \sphinxcode{\sphinxupquote{cpu}}, default value: \sphinxcode{\sphinxupquote{1}}): number of threads to use for computing clause statistics in scoring clause refinements and parameter learning. If \sphinxcode{\sphinxupquote{cpu}}, the number of threads is equal to the number of cores of the machine.

\end{itemize}


\chapter{Example Files}
\label{\detokenize{index:example-files}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{pack/liftcover/prolog/examples}} folder in SWI\sphinxhyphen{}Prolog home contains some example programs.
The \sphinxcode{\sphinxupquote{pack/liftcover/docs}} folder contains this manual in latex, html and pdf.


\chapter{Manual in PDF}
\label{\detokenize{index:manual-in-pdf}}
\sphinxAtStartPar
A PDF version of the manual is available at \sphinxurl{https://friguzzi.github.io/liftcover/\_build/latex/liftcover.pdf}.


\chapter{License}
\label{\detokenize{index:license}}
\sphinxAtStartPar
phil follows the MIT License that you can find in phil root folder.
The copyright is by Fabrizio Riguzzi and Arnaud Nguembang Fadja.

\begin{sphinxthebibliography}{DRVL95}
\bibitem[Coh95]{index:id23}
\sphinxAtStartPar
WilliamW. Cohen. Pac\sphinxhyphen{}learning non\sphinxhyphen{}recursive prolog clauses. \sphinxstyleemphasis{Artif. Intell.}, 79(1):1\textendash{}38, 1995.
\bibitem[DRVL95]{index:id22}
\sphinxAtStartPar
L.DeRaedt and W.VanLaer. Inductive constraint logic. In \sphinxstyleemphasis{Proceedings of the 6th Conference on Algorithmic Learning Theory (ALT 1995)}, volume 997 of LNAI, 80\textendash{}94. Fukuoka, Japan, 1995. Springer.
\bibitem[GBA+23]{index:id7}
\sphinxAtStartPar
Elisabetta Gentili, Alice Bizzarri, Damiano Azzolini, Riccardo Zese, and Fabrizio Riguzzi. Regularization in probabilistic inductive logic programming. In Elena Bellodi, FrancescaAlessandra Lisi, and Riccardo Zese, editors, \sphinxstyleemphasis{Inductive Logic Programming \sphinxhyphen{} ILP 2023}, volume 14363 of Lecture Notes in Artificial Intelligence, 16\textendash{}29. Cham, 2023. Springer Nature Switzerland. \sphinxhref{https://doi.org/10.1007/978-3-031-49299-0\_2}{doi:10.1007/978\sphinxhyphen{}3\sphinxhyphen{}031\sphinxhyphen{}49299\sphinxhyphen{}0\_2}.
\bibitem[KD05]{index:id29}
\sphinxAtStartPar
Stanley Kok and Pedro Domingos. Learning the structure of markov logic networks. In \sphinxstyleemphasis{Proceedings of the 22nd international conference on Machine learning}, 441\textendash{}448. 2005.
\bibitem[NFR19]{index:id34}
\sphinxAtStartPar
Arnaud NguembangFadja and Fabrizio Riguzzi. Lifted discriminative learning of probabilistic logic programs. \sphinxstyleemphasis{Machine Learning}, 108(7):1111\textendash{}1135, 2019. \sphinxhref{https://doi.org/10.1007/s10994-018-5750-0}{doi:10.1007/s10994\sphinxhyphen{}018\sphinxhyphen{}5750\sphinxhyphen{}0}.
\bibitem[VV03]{index:id24}
\sphinxAtStartPar
J.Vennekens and S.Verbaeten. Logic programs with annotated disjunctions. Technical Report CW386, K. U. Leuven, 2003.
\bibitem[VVB04]{index:id8}
\sphinxAtStartPar
J.Vennekens, S.Verbaeten, and M.Bruynooghe. Logic programs with annotated disjunctions. In \sphinxstyleemphasis{International Conference on Logic Programming}, volume 3131 of LNCS, 195\textendash{}209. Springer, 2004.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}